# 排序算法与伪代码

## Part I 回答问题

1. Bubble Sort the list: 33, 56, 17, 8, 95, 22。Make sure the final result is
from small to large.
Write out the list after the 2nd pass. (10 points)    
2. Give a sorted array as list={60,65,75,80,90,95}. Design an algorithm to
insert the value of x into the sorted array. Then test the algorithm with
value 50,67,99.    
思考：为什么选择插入点在list头上、中间、尾巴上的三个数作为算
法测试的数据，你能解释吗？
3. What is the state of the stack after the following sequence of Push and
Pop operations?    
Push “anne”; Push “get”; Push “your” ; Pop; Push “my” Push “gun”

**THE ANSWER**    
    
**1.**
```
list={33,56,17,8,95,22}
FOR i from 0 to list.length-1 DO
    flag=0;
    FOR j from 0 to list.length-2-i DO
    IF list[j]>list[j+1] DO
        swap(list[j],list[j+1])
        flag=1
    IF flag==0 
        END FOR

END FOR
```
**2.**
伪代码描述：
```
list={60,65,75,80,90,95}
mid=(list.start+list.end)/2
IF list[mid]>insert AND list[mid-1]>insert THEN 
new_mid=(list.start+mid-1)/2
ELSE
    INSERT(insert,mid)

IF list[mid]<insert AND list[mid+1]<insert THEN
new_mid=(mid+1+list.end)/2
ELSE
    INSERT(insert,mid)

```
C语言实现：
```C
#include <stdio.h>

int binary_insert(int,int*,int,int);
int main(int argc, const char * argv[]) {
    int tar;
    int list[8]={60,65,75,80,90,95,0};
    
    scanf("%d",&tar);
    int t=binary_insert(tar,list,0,5);
    for(int i=7;i>t;i--){
        list[i]=list[i-1];
    }
    list[t]=tar;
    
    for(int i=0;i<8;i++){
        printf("%d ",list[i]);
    }
    return 0;
}

int binary_insert(int a,int* b,int start,int end){
    if(start>end)
        return -1;
    
    int mid=(start+end)/2;
    if(b[mid]>=a){
    if(b[mid]>=a&&b[mid-1]<=a)
        return mid;
    else
        return  binary_insert(a,b,start,mid);
            
            }
    if(b[mid]<=a){
        if(b[mid+1]>=a)
            return mid+1;
        else
            return binary_insert(a, b, mid,end);
    }
    return 0;
}
```
思考题：头，中间，和尾端分别代表了三种情况，index=0；index=list.end;和index在list之间的插入情况。若这三个样例成功插入则可确定这个算法是有效的。    
3."anne get my gun"